from typing import List, Tuple

#  подвійний цикл - брут-форс
# O(n^2)   беремо перше число і пробуємо скласти його з кожним наступним; потім друге — з усіма після нього, і т.д.
#O(1)  — додаткових структур не зберігаємо.
def find_sum(target: int, li: List[int]) -> Tuple[int, int]: #перевірґемо кожну пару елементу списка


    for i in range(len(li)): #обираемо перший індекс пари
        for j in range(i + 1, len(li)): #обираемо другий індекс пари щоб не дублювати пари i +1, щоб не брати один і теж самий елемент,і не дублювати однакові пари в іншому порядку (уникнути (i, j) і (j, i))
            # Якщо сума саме та, яка нам потрібна — повертаємо індекси
            if li[i] + li[j] == target: #перевіряемо суми чи дають вони нам target
                return (i, j)
    #
    raise ValueError("Pair not found") # за умовою пара існує, але на випадок некоректних даних кидаємо зрозумілу помилку



#  set / dict (hash)
# O(n) — один лінійний прохід / O(n) — можемо зберігати до n потрібних значень

def find_sum_fast(target: int, li: List[int]) -> Tuple[int, int]:     #шуквемо пару зв один прохід по списку
    needed_index = {}  #порожній словник, куди будемо додавати записи типу потрібне_число -> індекс партнера в li


    # Перебираємо список зліва направо
    for j, x in enumerate(li):       # j — індекс, x — поточне число

        if x in needed_index:    # тут превіряемо якщо це 'x' те, що ми шукали раніше, значить пара знайдена

            i = needed_index[x]   ## needed_index[x] дає нам індекс першого числа
            return (i, j)     # Повертаємо кортеж з індексами двох чисел, які у сумі дають target



        need = target - x              # Якщо пари чисел немає
                                        # Розраховуємо, яке число нам потрібно побачити далі, щоб з x утворити target
        needed_index[need] = j      #ми запамятовуємо, яке число треба побачити пізніше і з яким індексом його поєднати,щоб отримати target.


    raise ValueError("Pair not found")    # чкщо пройшли весь список і пару не знайшли,за умовою відповідь має існувати, але на випадок помилки




assert find_sum(5, [1, 2, 3, 4, 5]) in {(0, 3), (1, 2)}    #(0, 3) — тобто li[0] = 1 і li[3] = 4 → 1 + 4 = 5
                                                                   #(1, 2) — тобто li[1] = 2 і li[2] = 3 → 2 + 3 = 5
assert find_sum_fast(5, [1, 2, 3, 4, 5]) in {(0, 3), (1, 2)}
print("Good")          #Обидва assert пройшли без помилок